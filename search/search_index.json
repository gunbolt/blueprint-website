{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#whats-blueprint","title":"What's Blueprint?","text":"<p>Blueprint is a framework for writing reusable and testable HTML templates in plain Crystal, allowing an oriented object approach when building web views.</p>  Alert Output <pre><code>class Alert\ninclude Blueprint::HTML\nprivate def blueprint\ndiv class: \"alert alert-success\" do\nh4(class: \"alert-heading\") { \"Well done!\" }\np { \"Nice message here\" }\nend\nend\nend\n</code></pre> <pre><code>&lt;div class=\"alert alert-success\"&gt;\n&lt;h4 class=\"alert-heading\"&gt;Well done!&lt;/h4&gt;\n&lt;p&gt;Nice message here&lt;/p&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"#why-use-blueprint","title":"Why use Blueprint?","text":"<p>The benefits of using Blueprint to build HTML templates:</p> <ul> <li>Pure Crystal: One of the biggest benefits of using Crystal is its syntax, and using Blueprint you can take advantage of this syntax when building HTML.</li> <li>Oriented Object Programming: Blueprint makes it easy to create sustainable code, breaking web views in small pieces, encapsulating logic in its specialized views classes, following best practices principles, eg. Single responsability.</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>In <code>shard.yml</code>, add:</p> <pre><code>dependencies:\nblueprint:\ngithub: stephannv/blueprint\n</code></pre> <p>And run <code>shards install</code>.</p>"},{"location":"changelogs/v0.1.0/","title":"v0.1.0","text":"<p>Release date: 2023.03.23</p>"},{"location":"changelogs/v0.1.0/#added","title":"Added","text":"<ul> <li>Basic html builder</li> <li>Allow element attributes</li> <li>Allow rendering blueprints</li> <li>Allow NamedTuple attributes</li> <li>Add <code>doctype</code> util</li> <li>Transform attribute names</li> <li>Handle boolean attributes</li> <li>Escape content</li> <li>Add <code>comment</code> util</li> <li>Add <code>whitespace</code> util</li> <li>Allow custom component registration</li> <li>Allow custom element registration</li> </ul>"},{"location":"changelogs/v0.2.0/","title":"v0.2.0","text":"<p>Release date: 2023.04.07</p>"},{"location":"changelogs/v0.2.0/#added","title":"Added","text":""},{"location":"changelogs/v0.2.0/#allow-conditional-rendering","title":"Allow conditional rendering","text":"<p>It's possible to override <code>#render?</code> method to control blueprint render.</p> <pre><code>class Example\ninclude Blueprint::HTML\nprivate def blueprint\nh1 { \"Example\" }\nend\nprivate def render?\nfalse\nend\nend\nexample = Example.new\nexample.to_html # =&gt; \"\"\n</code></pre>"},{"location":"changelogs/v0.2.0/#handles-array-attributes","title":"Handles array attributes","text":"<p>Arrays passed as attribute values will be flattened and joined with <code>\" \"</code>.</p> <pre><code>class Example\ninclude Blueprint::HTML\nprivate def blueprint\nh1(class: [\"a\", \"b\", [\"c\", \"d\"]) { \"Example\" }\nend\nend\nexample = Example.new\nexample.to_html # =&gt; \"&lt;h1 class=\"a b c d\"&gt;Example&lt;/h1&gt;\"\n</code></pre>"},{"location":"changelogs/v0.2.0/#adds-envelope-method","title":"Adds <code>#envelope(&amp;)</code> method","text":"<p>By overriding the <code>#envelope(&amp;)</code> method, you can create a wrapper around blueprint content. This is useful when defining layouts for pages.</p> <pre><code>class Example\ninclude Blueprint::HTML\nprivate def blueprint\nh1 { \"Example\" }\nend\nprivate def envelope(&amp;)\nhtml do\nbody do\nyield\nend\nend\nend\nend\nexample = Example.new\nexample.to_html # =&gt; \"&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\"\n</code></pre>"},{"location":"changelogs/v0.2.0/#breaking-changes","title":"Breaking changes","text":"<ul> <li>Requires <code>require \"blueprint/html\"</code> instead <code>require \"blueprint\"</code> to use <code>Blueprint::HTML</code> module</li> </ul>"},{"location":"changelogs/v0.3.0/","title":"v0.3.0","text":"<p>Release date: 2023.04.18</p>"},{"location":"changelogs/v0.3.0/#added","title":"Added","text":""},{"location":"changelogs/v0.3.0/#build-html-without-defining-classes-or-structs","title":"Build HTML without defining classes or structs","text":"<p>It's possible build HTML without using classes or structs</p> <pre><code>html = Blueprint::HTML.build do\nh1 { \"Hello\" }\ndiv do\nh2 { \"World\" }\nend\nend\nputs html # =&gt; &lt;h1&gt;Hello&lt;/h1&gt;&lt;div&gt;&lt;h2&gt;World&lt;/h2&gt;&lt;/div&gt;\n</code></pre>"},{"location":"changelogs/v0.4.0/","title":"v0.4.0","text":"<p>Release date: 2023.04.25</p>"},{"location":"changelogs/v0.4.0/#added","title":"Added","text":""},{"location":"changelogs/v0.4.0/#svg-support","title":"SVG support","text":"<p>It's possible to create SVG elements:</p> <pre><code>class Example\ninclude Blueprint::HTML\nprivate def blueprint\nsvg width: 30, height: 10 do\ng fill: :red do\nrect x: 0, y: 0, width: 10, height: 10\nrect x: 20, y: 0, width: 10, height: 10\nend\nend\nend\nend\n</code></pre> <p>Output: <pre><code>&lt;svg width=\"30\" height=\"10\"&gt;\n&lt;g fill=\"red\"&gt;\n&lt;rect x=\"0\" y=\"0\" width=\"10\" height=\"10\"&gt;&lt;/rect&gt;\n&lt;rect x=\"20\" y=\"0\" width=\"10\" height=\"10\"&gt;&lt;/rect&gt;\n&lt;/g&gt;\n&lt;/svg&gt;\n</code></pre></p>"},{"location":"guides/attributes/","title":"Attributes","text":""},{"location":"guides/attributes/#overview","title":"Overview","text":"<p>HTML element methods, eg. <code>#h1</code>, <code>#meta</code>, <code>#div</code>, etc, accepts a NamedTuple as parameter, so it is possible to pass any attributes to an HTML element.</p>  ExamplePage Output <pre><code>class ExamplePage\ninclude Blueprint::HTML\nprivate def blueprint\ndiv x: 1, y: 2.5, foo: :bar do\ninput \"@blur\": \"doSomething\", v_model: \"user.name\"\nend\nend\nend\n</code></pre> <pre><code>&lt;div x=\"1\" y=\"1.2\" foo=\"bar\"&gt;\n&lt;input @blur=\"doSomething\" v-model=\"user.name\"&gt;\n&lt;/div&gt;\n</code></pre> <p>Attribute name conversion</p> <p>Note that Blueprint parses all attributes name replacing <code>_</code> by <code>-</code></p>"},{"location":"guides/attributes/#namedtuple-attributes","title":"NamedTuple attributes","text":"<p>If you pass a NamedTuple attribute to some element attribute, it will be flattened with a dash between each level. This is useful for <code>data-*</code> and <code>aria-*</code> attributes.</p>  ExamplePage Output <pre><code>class ExamplePage\ninclude Blueprint::HTML\nprivate def blueprint\ndiv data: { id: 42, target: \"#home\" }, aria: { selected: \"true\" } do\n\"Home\"\nend\nend\nend\n</code></pre> <pre><code>&lt;div data-id=\"42\" data-target=\"#home\" aria-selected=\"true\"&gt;\n  Home\n&lt;/div&gt;\n</code></pre>"},{"location":"guides/attributes/#boolean-attributes","title":"Boolean attributes","text":"<p>If you pass <code>true</code> to some attribute, it will be rendered as a boolean HTML attribute, in other words, just the attribute name will be rendered without the value. If you pass <code>false</code> the attribute will not be rendered. If you want the attribute value to be <code>\"true\"</code> or <code>\"false\"</code>, use <code>true</code> and <code>false</code> between quotes.</p>  ExamplePage Output <pre><code>class ExamplePage\ninclude Blueprint::HTML\nprivate def blueprint\ninput required: true, disabled: false, x: \"true\", y: \"false\"\nend\nend\n</code></pre> <pre><code>&lt;input required x=\"true\" y=\"false\"&gt;\n</code></pre>"},{"location":"guides/attributes/#array-attributes","title":"Array attributes","text":"<p>If you pass an Array as attribute value, it will be flattened and joined using <code>\" \"</code> as separator.</p>  ExamplePage Output <pre><code>class ExamplePage\ninclude Blueprint::HTML\nprivate def blueprint\ndiv class: [\"a\", \"b\", [\"c\", \"d\"]] do\n\"Hello\"\nend\nend\nend\n</code></pre> <pre><code>&lt;div class=\"a b c d\"&gt;\n  Hello\n&lt;/div&gt;\n</code></pre>"},{"location":"guides/builder/","title":"Builder","text":""},{"location":"guides/builder/#overview","title":"Overview","text":"<p>Blueprint provides a builder for those cases when you don't need or don't want to create a class or struct to write HTML.</p>  Main Output <pre><code>html = Blueprint::HTML.build do\nh1 { \"Hello\" }\ndiv do\nspan { \"World\" }\nend\nend\nputs html\n</code></pre> <pre><code>&lt;h1&gt;Hello&lt;/h1&gt;\n&lt;div&gt;\n&lt;span&gt;World&lt;/span&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"guides/components/","title":"Creating Components","text":""},{"location":"guides/components/#overview","title":"Overview","text":"<p>You can create reusable components using Blueprint, you just need to pass a component instance to the <code>#render</code> method.</p>  AlertComponent ExamplePage Output <pre><code>class AlertComponent\ninclude Blueprint::HTML\ndef initialize(@content : String, @type : String); end\nprivate def blueprint\ndiv class: \"alert alert-#{@type}\", role: \"alert\" do\n@content\nend\nend\nend\n</code></pre> <pre><code>class ExamplePage\ninclude Blueprint::HTML\nprivate def blueprint\nh1 { \"Hello\" }\nrender AlertComponent.new(content: \"My alert\", type: \"primary\")\nend\nend\n</code></pre> <pre><code>&lt;h1&gt;Hello&lt;/h1&gt;\n&lt;div class=\"alert alert-primary\" role=\"alert\"&gt;\n  My alert\n&lt;/div&gt;\n</code></pre> <p>Pages vs. Views vs. Components</p> <p>Please note that while these doc pages will use terms like views, pages and components to describe conceptual differences, in code all classes are implemented in the same way, there is no difference in practice. The <code>Blueprint::HTML</code> module must be included, which uses the <code>#blueprint</code> method to define an HTML structure.</p>"},{"location":"guides/components/#passing-content","title":"Passing Content","text":"<p>Sometimes you need to pass complex content that cannot be passed through a constructor parameter. To accomplish this, the <code>blueprint</code> method needs to receive a block (<code>&amp;</code>) and yield it. Refactoring the previous Alert component example:</p>  AlertComponent ExamplePage Output <pre><code>class AlertComponent\ninclude Blueprint::HTML\ndef initialize(@type : String); end\nprivate def blueprint(&amp;)\ndiv class: \"alert alert-#{@type}\", role: \"alert\" do\nyield\nend\nend\nend\n</code></pre> <pre><code>class ExamplePage\ninclude Blueprint::HTML\nprivate def blueprint\nh1 { \"Hello\" }\nrender AlertComponent.new(type: \"primary\") do\nh4(class: \"alert-heading\") { \"My Alert\" }\np { \"Alert body\" }\nend\nend\nend\n</code></pre> <pre><code>&lt;h1&gt;Hello&lt;/h1&gt;\n&lt;div class=\"alert alert-primary\" role=\"alert\"&gt;\n&lt;h4 class=\"alert-heading\"&gt;My alert&lt;/h4&gt;\n&lt;p&gt;Alert body&lt;/p&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"guides/components/#composing-components","title":"Composing Components","text":"<p>Blueprint components can expose some predefined structure to its users. This can be accomplished by defining public instance methods that can accept blocks or not. Refactoring the previous Alert component example:</p>  AlertComponent ExamplePage Output <pre><code>class AlertComponent\ninclude Blueprint::HTML\ndef initialize(@type : String); end\nprivate def blueprint(&amp;)\ndiv class: \"alert alert-#{@type}\", role: \"alert\" do\nyield\nend\nend\ndef title(&amp;)\nh4(class: \"alert-heading\") { yield }\nend\ndef body(&amp;)\np { yield }\nend\nend\n</code></pre> <pre><code>class ExamplePage\ninclude Blueprint::HTML\nprivate def blueprint\nh1 { \"Hello\" }\nrender AlertComponent.new(type: \"primary\") do |alert|\nalert.title { \"My Alert\" }\nalert.body { \"Alert body\" }\nend\nend\nend\n</code></pre> <pre><code>&lt;h1&gt;Hello&lt;/h1&gt;\n&lt;div class=\"alert alert-primary\" role=\"alert\"&gt;\n&lt;h4 class=\"alert-heading\"&gt;My alert&lt;/h4&gt;\n&lt;p&gt;Alert body&lt;/p&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"guides/components/#registering-components","title":"Registering Components","text":"<p>Blueprint has the <code>register_component</code> macro. It is useful to avoid writing the fully qualified name of the component class. Instead writing something like <code>render Views::Components::Forms::LabelComponent.new(for: \"password\")</code> you could write just <code>label_component(for: \"password\")</code>.</p> <p>Blueprint::HTML::ComponentRegistrar</p> <p>You need to require <code>\"blueprint/html/component_registrar\"</code> and include the <code>Blueprint::HTML::ComponentRegistrar</code> module to make <code>register_component</code> macro available.</p>  ExamplePage AlertComponent Output <pre><code>require \"blueprint/html/component_registrar\"\nclass ExamplePage\ninclude Blueprint::HTML\ninclude Blueprint::HTML::ComponentRegistrar\nregister_component :alert_component, AlertComponent\nprivate def blueprint\nh1 { \"Hello\" }\nalert_component(type: \"primary\") do |alert|\nalert.title { \"My Alert\" }\nalert.body { \"Alert body\" }\nend\nend\nend\n</code></pre> <pre><code>class AlertComponent\ninclude Blueprint::HTML\ndef initialize(@type : String); end\nprivate def blueprint(&amp;)\ndiv class: \"alert alert-#{@type}\", role: \"alert\" do\nyield\nend\nend\ndef title(&amp;)\nh4(class: \"alert-heading\") { yield }\nend\ndef body(&amp;)\np { yield }\nend\nend\n</code></pre> <pre><code>&lt;h1&gt;Hello&lt;/h1&gt;\n&lt;div class=\"alert alert-primary\" role=\"alert\"&gt;\n&lt;h4 class=\"alert-heading\"&gt;My alert&lt;/h4&gt;\n&lt;p&gt;Alert body&lt;/p&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"guides/conditional-rendering/","title":"Conditional Rendering","text":"<p>Blueprints objects can implement a <code>#render?</code> method, if this method returns false, the blueprint will not be rendered. This allows you extract the conditional logic from component consumer and put in the component itself.</p>  DraftAlert ArticlePage Main Output <pre><code>class DraftAlert\ninclude Blueprint::HTML\ndef initialize(@article : Article); end\nprivate def blueprint\ndiv(class: \"alert alert-warning\") { \"This is a draft\" }\nend\nprivate def render?\n@article.draft?\nend\nend\n</code></pre> <pre><code>class ArticlePage\ninclude Blueprint::HTML\ndef initialize(@article: Article); end\nprivate def blueprint\n# Instead of writing:\n# if @article.draft?\n#   render DraftAlert.new(@article)\n# end\nrender DraftAlert.new(@article)\nh1 { @article.title }\nend\nend\n</code></pre> <pre><code>article = Article.new(title: \"Hello Blueprint\", draft: false)\npage = ArticlePage.new(article: article)\npage.to_html\n</code></pre> <pre><code>&lt;h1&gt;Hello Blueprint&lt;/h1&gt;\n</code></pre>"},{"location":"guides/enveloping/","title":"Enveloping","text":"<p>By overriding the <code>#envelope(&amp;)</code> method, you can create a wrapper around blueprint content. This is useful when defining layouts for pages, for example.</p>  ExamplePage Output <pre><code>class ExamplePage\ninclude Blueprint::HTML\nprivate def blueprint\nh1 { \"Home\" }\nend\nprivate def envelope(&amp;)\nhtml do\nbody do\nyield\nend\nend\nend\nend\n</code></pre> <pre><code>&lt;html&gt;\n&lt;body&gt;\n&lt;h1&gt;Home&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"guides/getting-started/","title":"Getting started","text":""},{"location":"guides/getting-started/#basic-usage","title":"Basic Usage","text":"<p>After installing the shard, you will need to follow three steps to start using Blueprint:</p> <ol> <li>Require <code>\"blueprint/html\"</code></li> <li>Include <code>Blueprint::HTML</code> module</li> <li>Define a <code>#blueprint</code> method to write the HTML structure inside.</li> </ol>  ExamplePage <pre><code>require \"blueprint/html\"\nclass ExamplePage\ninclude Blueprint::HTML\nprivate def blueprint\nh1 { \"Hello World\" }\nend\nend\n</code></pre> <p>Your view class is now defined, to render it it's necessary to instantiate it and call <code>#to_html</code> method.</p>  Main <pre><code>example = Example.new\nexample.to_html # =&gt; \"&lt;h1&gt;Hello World&lt;/h1&gt;\n</code></pre>"},{"location":"guides/getting-started/#blueprints-are-just-pocos","title":"Blueprints Are Just POCOs","text":"<p>You are using just Plain Old Crystal Objects (POCOs). The <code>Blueprint::HTML</code> just add helper methods to handle the HTML building stuff and your class can have its own logic. For example, if you want pass data to your view object:</p>  ProfilePage Main Output <pre><code>class ProfilePage\ninclude Blueprint::HTML\ndef initialize(@user : User); end\nprivate def blueprint\nh1 { @user.name }\nadmin_badge if admin?\nend\nprivate def admin_badge\nimg src: \"admin-badge.png\"\nend\nprivate def admin?\n@user.role == \"admin\"\nend\nend\n</code></pre> <pre><code>user = User.new(name: \"Jane Doe\", role: \"admin\")\npage = ProfilePage.new(user: user)\npage.to_thml\n</code></pre> <pre><code>&lt;h1&gt;Jane Doe&lt;/h1&gt;\n&lt;img src=\"admin-badge.png\"&gt;\n</code></pre> <p>It is possible even use structs instead of classes:</p>  Main <pre><code>struct Card\ninclude Blueprint::HTML\nprivate def blueprint\ndiv(class: \"card\") { \"Hello\" }\nend\nend\n# or using `record` macro\nrecord Alert, message : String do\ninclude Blueprint::HTML\nprivate def blueprint\ndiv(class: \"alert\") { @message }\nend\nend\ncard = Card.new\ncard.to_html # =&gt; &lt;div class=\"card\"&gt;Hello&lt;/div&gt;\nalert = Alert.new(message: \"Hello\")\nalert.to_html # =&gt; &lt;div class=\"alert\"&gt;Hello&lt;/div&gt;\n</code></pre>"},{"location":"guides/getting-started/#passing-content","title":"Passing Content","text":"<p>If you want to pass content when rendering a blueprint, you should define the <code>#blueprint(&amp;)</code> method and yield the block.</p>  Alert Main Output <pre><code>class Alert\ninclude Blueprint::HTML\nprivate def blueprint(&amp;)\ndiv class: \"alert\" do\nyield\nend\nend\nend\n</code></pre> <pre><code>alert = Alert.new\nalert.to_html { \"Hello World\" }\n</code></pre> <pre><code>&lt;div class=\"alert\"&gt;\n  Hello World\n&lt;/div&gt;\n</code></pre>"},{"location":"guides/getting-started/#code-style","title":"Code style","text":"<p>If you are new to Crystal, know that blocks can be passed using <code>do ... end</code> or <code>{ ... }</code>. All of these are equivalent:</p> <pre><code># With `do ... end` blocks\nprivate def blueprint\nhtml lang: \"pt-BR\" do\nhead do\ntitle do\n\"Blueprint\"\nend\nend\nbody do\nh1 class: \"heading\" do\n\"Hello World\"\nend\nend\nend\nend\n# With `{ ... }` blocks\nprivate def blueprint\nhtml lang: \"pt-BR\" {\nhead {\ntitle {\n\"Blueprint\"\n}\n}\nbody {\nh1 class: \"heading\" {\n\"Hello World\"\n}\n}\n}\nend\n</code></pre> <p>It's a personal or team preference, you can stick to one style or mix two styles (eg. Use <code>do ... end</code> for multiline blocks and <code>{ ... }</code> for inline blocks). But note that in Crystal the difference between using <code>do ... end</code> and <code>{ ... }</code> is that <code>do ... end</code> binds to the left-most call, while <code>{ ... }</code> binds to the right-most call:</p> <p>With <code>do ... end</code> blocks: <pre><code>private def blueprint\nrender Alert.new do\n\"Hello World\"\nend\nend\n# The above is same as\nprivate def blueprint\nrender(Alert.new) do\n\"Hello World\"\nend\nend\n</code></pre></p> <p>While using <code>{ ... }</code> blocks: <pre><code>private def blueprint\nrender Alert.new {\n\"Hello World\"\n}\nend\n# The above is same as\nprivate def blueprint\nrender(Alert.new {\n\"Hello World\"\n})\nend\n</code></pre></p> <p>The above example will raise an error <code>Error: 'Alert.new' is not expected to be invoked with a block, but a block was given</code>, to fix this you need to add parentheses to <code>render</code> call when using with <code>{ ... }</code>.</p> <pre><code>private def blueprint\nrender(Alert.new) {\n\"Hello World\"\n}\nend\n</code></pre>"},{"location":"guides/safety/","title":"Safety","text":"<p>When using Blueprint all content and attribute values passed to elements and components are escaped.</p>  ExamplePage Output <pre><code>class ExamplePage\ninclude Blueprint::HTML\nprivate def blueprint\nspan { \"&lt;script&gt;alert('hello')&lt;/script&gt;\" }\ninput(class: \"some-class\\\" onblur=\\\"alert('Attribute')\")\nend\nend\n</code></pre> <pre><code>&lt;span&gt;&amp;lt;script&amp;gt;alert(&amp;#39;hello&amp;#39;)&amp;lt;/script&amp;gt;&lt;/span&gt;\n&lt;input class=\"some-class&amp;quot; onblur=&amp;quot;alert(&amp;#39;Attribute&amp;#39;)\"&gt;\n</code></pre>"},{"location":"guides/svg/","title":"SVG","text":"<p>Blueprint supports SVG elements.</p>  ExamplePage Output <pre><code>class ExamplePage\ninclude Blueprint::HTML\nprivate def blueprint\nsvg xmlns: \"http://www.w3.org/2000/svg\", width: 30, height: 10 do\ng fill: :red do\nrect x: 0, y: 0, width: 10, height: 10\nrect x: 20, y: 0, width: 10, height: 10\nend\nend\nend\nend\n</code></pre> <pre><code>&lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"30\" height=\"10\"&gt;\n&lt;g fill=\"red\"&gt;\n&lt;rect x=\"0\" y=\"0\" width=\"10\" height=\"10\"&gt;&lt;/rect&gt;\n&lt;rect x=\"20\" y=\"0\" width=\"10\" height=\"10\"&gt;&lt;/rect&gt;\n&lt;/g&gt;\n&lt;/svg&gt;\n</code></pre> <p>You should note that SVG elements methods are accessible only inside <code>#svg</code> method block, using a SVG element outside SVG block will result in a compilation error.</p> <pre><code>class ExamplePage\ninclude Blueprint::HTML\nprivate def blueprint\nsvg do\npath d: \"M3.75 9h16.5m-16.5 6.75h16.5\" # OK\nend\n# Error: undefined local variable or method 'path' for ExamplePage\npath d: \"M3.75 9h16.5m-16.5 6.75h16.5\"\nend\nend\n</code></pre>"},{"location":"guides/utils/","title":"Utils","text":""},{"location":"guides/utils/#helper-methods","title":"Helper methods","text":"<p>Blueprint provide some utility methods to help you build your HTML:</p> <ul> <li><code>#doctype</code> - adds HTML 5 doctype declaration</li> <li><code>#plain</code> - writes plain text on HTML without tags</li> <li><code>#whitespace</code> - adds a simple whitespace to HTML</li> <li><code>#comment</code> - allows writing HTML comments</li> </ul>  ExamplePage Output <pre><code>class ExamplePage\ninclude Blueprint::HTML\nprivate def blueprint\ndoctype\ncomment { \"This is an HTML comment\" }\nh1 do\nplain \"Hello\"\nwhitespace\nstrong { \"Jane Doe\" }\nend\nend\nend\n</code></pre> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;!--This is an HTML comment--&gt;\n&lt;h1&gt;\n  Hello &lt;strong&gt;Jane Doe&lt;/strong&gt;\n&lt;/h1&gt;\n</code></pre>"},{"location":"guides/utils/#custom-tags","title":"Custom tags","text":"<p>You can register custom HTML tags using the <code>register_element</code> macro. The first argument is the helper method and the second argument is an optional tag name.</p>  ExamplePage Output <pre><code>class ExamplePage\ninclude Blueprint::HTML\nregister_element :trix_editor\nregister_element :my_button, \"v-btn\"\nprivate def blueprint\ntrix_editor\nmy_button(to: \"#home\") { \"My button\" }\nend\nend\n</code></pre> <pre><code>&lt;trix-editor&gt;&lt;/trix-editor&gt;\n&lt;v-btn to=\"#home\"&gt;My button&lt;/v-btn&gt;\n</code></pre> <p>It is possible to use <code>register_void_element</code> and <code>register_empty_element</code> in case if want you elements without closing tags or elements that doesn't accept content.</p>  ExamplePage Output <pre><code>class ExamplePage\ninclude Blueprint::HTML\nregister_void_element :my_tag\nregister_empty_element :my_empty_tag\nprivate def blueprint\nmy_tag\nmy_empty_tag\nend\nend\n</code></pre> <pre><code>&lt;my-tag&gt;\n&lt;my-empty-tag&gt;&lt;/my-empty-tag&gt;\n</code></pre>"},{"location":"integrations/kemal/","title":"Kemal","text":"<p>Kemal is a lightning fast, super simple web framework. The framework built-in view templating uses ECR but it can be integrated with Blueprint since any string returned from a route will output to the browser.</p>  App <pre><code>require \"kemal\"\nrequire \"blueprint/html\"\nclass HomePage\ninclude Blueprint::HTML\nprivate def blueprint\nh1 { \"Hello World!\" }\nend\nend\nget \"/\" do\nHomePage.new.to_html\nend\nKemal.run\n</code></pre> <p>Run <code>crystal run src/your_app.cr</code> and visit <code>http://0.0.0.0:3000</code>. You should see a big Hello Word!.</p> <p>This repo is a proof-of-concept integrating Kemal + Blueprint, using a mini design system, page layout, Tailwind and component registration.</p>"},{"location":"integrations/lucky/","title":"Lucky","text":"<p>Lucky is a fully-featured web framework and it comes already with a great built-in HTML builder feature, tightly integrated with the framework, so the recommendation is to keep using <code>Lucky::HTMLPage</code> and <code>Lucky::BaseComponent</code> to build Lucky views.</p>"},{"location":"recipes/design-system-components/","title":"Design System Components","text":"<p>If you are using Blueprint to build a design system or a lot of base components, eg. buttons, tabs, cards, alerts, etc. you will end up writing fully-qualified class name when consuming components. For example:</p>  ExamplePage <pre><code>class ExamplePage\ninclude Blueprint::HTML\nprivate def blueprint\nrender Structures::PageComponent.new do |page|\npage.title { \"Example\" }\npage.body do\nrender Feedback::AlertComponent.new do |alert|\nalert.title { \"Warning\" }\nalert.body { \"Your account couldn't be verified\" }\nend\nend\nend\nend\nend\n</code></pre> <p>But you can take advantage of <code>Blueprint::HTML::ComponentRegistrar</code> module to register your components, simplifying your life. You can create a module to register the components and include it where needed.</p>  ComponentHelpers BasePage ExamplePage <pre><code>require \"blueprint/html/component_registrar\"\nmodule ComponentHelpers\nregister_component :page_component, Structures::PageComponent\nregister_component :alert_component, Feedback::AlertComponent\n# ... more components here\nend\n</code></pre> <pre><code>class BasePage\ninclude Blueprint::HTML\ninclude ComponentHelpers\nend\n</code></pre> <pre><code>class ExamplePage &lt; BasePage\nprivate def blueprint\npage_component do |page|\npage.title { \"Example\" }\npage.body do\nalert_component do |alert|\nalert.title { \"Warning\" }\nalert.body { \"Your account couldn't be verified\" }\nend\nend\nend\nend\nend\n</code></pre>"},{"location":"recipes/multiple-layouts/","title":"Multiple layouts","text":"<p>There are some ways to solve the problem of pages needing multiple layouts. The enveloping guide can introduce you the <code>#envelope</code> method.</p>"},{"location":"recipes/multiple-layouts/#inheritance","title":"Inheritance","text":"<p>Your pages can inherit from layout classes.</p>  MainLayout AuthLayout LoginPage HomePage <pre><code>class MainLayout\ninclude Blueprint::HTML\nabstract def blueprint\nprivate def envelope(&amp;)\nhtml do\nbody do\ndiv class: \"main-layout\" do\nyield\nend\nend\nend\nend\nend\n</code></pre> <pre><code>class AuthLayout\ninclude Blueprint::HTML\nabstract def blueprint\nprivate def envelope(&amp;)\nhtml do\nbody do\ndiv class: \"auth-layout\" do\nyield\nend\nend\nend\nend\nend\n</code></pre> <pre><code>class LoginPage &lt; AuthLayout\nprivate def blueprint\nh1 { \"Sign In\" }\nend\nend\n</code></pre> <pre><code>class LoginPage &lt; MainLayout\nprivate def blueprint\nh1 { \"Welcome\" }\nend\nend\n</code></pre>"},{"location":"recipes/multiple-layouts/#generics","title":"Generics","text":"<p>Your base page can have a generic type.</p>  BasePage LoginPage HomePage MainLayout AuthLayout <pre><code>class BasePage(T)\ninclude Blueprint::HTML\nabstract def blueprint\nprivate def envelope(&amp;)\nrender(T.new) do\nyield\nend\nend\nend\n</code></pre> <pre><code>class LoginPage &lt; BasePage(AuthLayout)\nprivate def blueprint\nh1 { \"Sign In\" }\nend\nend\n</code></pre> <pre><code>class LoginPage &lt; BasePage(MainLayout)\nprivate def blueprint\nh1 { \"Welcome\" }\nend\nend\n</code></pre> <pre><code>class MainLayout\ninclude Blueprint::HTML\nprivate def blueprint(&amp;)\nhtml do\nbody do\ndiv class: \"main-layout\" do\nyield\nend\nend\nend\nend\nend\n</code></pre> <pre><code>class AuthLayout\ninclude Blueprint::HTML\nprivate def blueprint(&amp;)\nhtml do\nbody do\ndiv class: \"auth-layout\" do\nyield\nend\nend\nend\nend\nend\n</code></pre>"}]}